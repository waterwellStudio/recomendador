package es.fdi.iw.controller;


import java.util.UUID;

import javax.persistence.EntityManager;
import javax.persistence.NoResultException;
import javax.persistence.PersistenceContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.transaction.Transactional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;


import es.fdi.iw.model.User;


/**
 * Handles requests for the application home page.
 */
@Controller
public class HomeController {


	@PersistenceContext
	private EntityManager entityManager;

	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);


	/**************************** LOGIN Y REGISTRO ******************************/

	@RequestMapping(value = "/", method = RequestMethod.GET)
	public String home(Model model) {
		return "login";
	}

	@RequestMapping(value = "/login", method = RequestMethod.GET)
	public String login(Model model) {
		return "login";
	}

	/** Intercepts login requests generated by the header; then continues to load normal page
	 **/
	@RequestMapping(value = "/login", method = RequestMethod.POST)
	@Transactional
	public String login(
			@RequestParam("login") String formLogin,
			@RequestParam("password") String formPass,
			HttpServletRequest request, HttpServletResponse response, 
			Model model, HttpSession session) {


		String formSource = "login";
		logger.info("Login attempt from '{}' while visiting '{}'", formLogin);

		// validate request
		if (formLogin == null || formLogin.length() < 4 || formPass == null || formPass.length() < 4) {
			model.addAttribute("loginError", "usuarios y contraseñas: 4 caracteres mínimo");
			response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
		} else {
			User u = null;
			try {
				u = (User)entityManager.createNamedQuery("userByLogin")
						.setParameter("loginParam", formLogin).getSingleResult();
				if (u.isPassValid(formPass)) {
					if (!u.isBanned()) {
						// sets the anti-csrf token
						getTokenForSession(session);
						logger.info("pass was valid");				
						session.setAttribute("user", u);
						if(u.getRole().equals("user"))
							formSource = "redirect:perfil";
						else if(u.getRole().equals("admin")){
							return "login";
						}
					} else {
						logger.info("you are banned");
						model.addAttribute("loginError", "Su cuenta esta baneada");
						response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
					}
				} else {
					logger.info("pass was NOT valid");
					model.addAttribute("loginError", "error en usuario o contraseña");
					response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
				}
			} catch (NoResultException nre) {
				logger.info("no such login: {}", formLogin);
				model.addAttribute("loginError", "error en usuario o contraseña");
			}
		}

		// redirects to view from which login was requested
		return formSource;
	}

	@RequestMapping(value = "/registrar", method = RequestMethod.GET)
	public String registrar(Model model) {
		return "registrar";
	}

	/**
	 * Intercepts login requests generated by the header; then continues to load normal page
	 */
	@RequestMapping(value = "/registro", method = RequestMethod.POST)
	@Transactional
	public String registro(
			@RequestParam("correo") String formLogin,
			@RequestParam("nombre") String formNombre,
			@RequestParam("password") String formPass,
			@RequestParam("repassword") String formRePass,
			@RequestParam("imagen") String formImagen,

			HttpServletRequest request, HttpServletResponse response, 
			Model model, HttpSession session) {

		logger.info("Login attempt from '{}' while visiting '{}'", formLogin);

		//Comprobamos los datos introducidos
		if (formLogin == null || formLogin.length() < 4 ||
				formNombre == null || formNombre.length() < 4 ||
				formPass == null || formPass.length() < 4) {
			model.addAttribute("registrerError", "Usuarios y contraseñas: 4 caracteres mínimo.");
			response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
			return "registrar";
		}

		//Comprobamos que su correo este disponible
		User u = null;
		try{
			u = (User)entityManager.createNamedQuery("userByLogin")
					.setParameter("loginParam", formLogin).getSingleResult();
			if (u != null) {
				model.addAttribute("registrerError", "¡Su correo ya esta siendo usado!");
				return "registrar";
			}
		}catch (NoResultException nre) {}

		//Comprobamos que el nombre de heroe no este usado
		
		User user = User.createUser(formLogin, formPass, "user", formNombre);

		if(formPass.equals(formRePass)){
			entityManager.persist(user);	
			session.setAttribute("user", user);
			return "redirect:perfil";
		}

		model.addAttribute("registrerError", "¡La contraseña no es la misma en los dos campos!");
		return "registrar";
	}

	/**
	 * Logout (also returns to home view).
	 */
	@RequestMapping(value = "/logout", 
			method = RequestMethod.GET)
	public String logout(HttpSession session) {
		logger.info("User '{}' logged out", 
				session.getAttribute("user"));
		session.invalidate();
		return "redirect:/";
	}



	/** 
	 * Returns true if the user is logged in and is an admin
	 */
	static boolean isAdmin(HttpSession session) {
		User u = (User)session.getAttribute("user");
		if (u != null) {
			return u.getRole().equals("admin");
		} else {
			return false;
		}
	}

	/**
	 * Returns an anti-csrf token for a session, and stores it in the session
	 * @param session
	 * @return
	 */
	static String getTokenForSession (HttpSession session) {
		String token=UUID.randomUUID().toString();
		session.setAttribute("csrf_token", token);
		return token;
	}


	/**
	 * Checks the anti-csrf token for a session against a value
	 * @param session
	 * @param token
	 * @return the token
	 */
	static boolean isTokenValid(HttpSession session, String token) {
		Object t=session.getAttribute("csrf_token");
		return (t != null) && t.equals(token);
	}
}
